replicaCount: 1

image:
  repository: ghcr.io/domatwonderful/s3-to-wonderful-rag
  tag: latest
  digest: ""
  pullPolicy: Always

imagePullSecrets: []

service:
  type: ClusterIP
  port: 80
  targetPort: 8080
  annotations: {}

# Prometheus/Victoria Metrics configuration
metrics:
  enabled: true
  port: 8080
  serviceMonitor:
    enabled: true
    # Additional labels for ServiceMonitor (required for victoria-metrics-k8s-stack discovery)
    labels:
      release: prometheus-operator
    # Annotations for ServiceMonitor
    annotations: {}
    # Scrape interval
    interval: "30s"
    # Scrape timeout
    scrapeTimeout: "10s"
    # Relabeling rules
    relabelings: []
    # Metric relabeling rules
    metricRelabelings: []

resources:
  requests:
    cpu: 100m
    memory: 256Mi
  limits:
    cpu: 500m
    memory: 512Mi

nameOverride: ""
fullnameOverride: ""

automountServiceAccountToken: false

serviceAccount:
  create: true
  name: ""

hpa:
  enabled: false
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 80

pdb:
  enabled: true
  maxUnavailable: 1

networkPolicy:
  enabled: true
  allowDns: true
  allowHttpsEgress: true
  # Restrict egress to specific IP ranges for better security
  # Leave empty to allow all HTTPS (not recommended for production)
  # Configure these based on your cloud provider and region
  allowedCidrs: []
  # Example AWS S3 IP ranges (us-east-1):
  # - 52.216.0.0/15
  # - 3.5.0.0/16
  # Example GCS IP ranges:
  # - 34.64.0.0/10
  # - 35.184.0.0/13
  # Example Azure Storage IP ranges:
  # - 20.38.0.0/16
  # - 20.150.0.0/16
  # Example Wonderful API (adjust based on actual infrastructure):
  # - 1.2.3.4/32  # Replace with actual IP

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 10001
  fsGroup: 10001
  seccompProfile:
    type: RuntimeDefault

containerSecurityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - ALL

extraVolumes:
  - name: tmp
    emptyDir: {}

extraVolumeMounts:
  - name: tmp
    mountPath: /tmp

# Node scheduling configuration
nodeSelector: {}

tolerations: []

affinity: {}

# Topology spread constraints for high availability
topologySpreadConstraints: []
# Example:
# - maxSkew: 1
#   topologyKey: topology.kubernetes.io/zone
#   whenUnsatisfiable: ScheduleAnyway
#   labelSelector:
#     matchLabels:
#       app.kubernetes.io/name: s3-to-wonderful-rag

env:
  storageProvider: s3
  awsRegion: us-east-1
  s3Bucket: ""
  s3Prefix: ""
  gcsBucket: ""
  gcsPrefix: ""
  azureStorageAccount: ""
  azureStorageContainer: ""
  azureStoragePrefix: ""
  wonderfulTenant: swiss-german
  wonderfulEnv: sb
  syncIntervalSeconds: "1800"
  syncIntervalMinutes: ""
  maxFileSizeMb: "0"
  port: "8080"

secrets:
  # SECURITY BEST PRACTICE: Use existingSecret with external secret management
  # (e.g., External Secrets Operator, Vault, Sealed Secrets)
  # Setting inline secrets via --set is INSECURE as they get stored in:
  # - Shell history
  # - Helm release history (plaintext)
  # - kubectl/helm command output
  existingSecret: ""

  # WARNING: The following inline secrets are provided for testing/development only
  # DO NOT use in production environments
  awsAccessKeyId: ""
  awsSecretAccessKey: ""
  azureStorageKey: ""
  azureStorageConnectionString: ""
  wonderfulRagId: ""
  wonderfulApiKey: ""
  # REQUIRED for production: API key for internal endpoints (/api/v1/sync, /api/v1/stats, etc.)
  # Without this, the service will deny access to these endpoints (fail-closed security)
  internalApiKey: ""
